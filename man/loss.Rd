% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loss.R
\name{loss}
\alias{loss}
\title{Compute CV loss over a tuning grid}
\usage{
loss(fitobj, y, yhat, n, family, type.measure = c("deviance", "class", "bic"))
}
\arguments{
\item{fitobj}{A fitted CME model (e.g., from \code{\link{glmcmenet}}) that
contains a 3D array \code{$coefficients} of shape
\code{(p_total) × n_lambda_sib × n_lambda_cou}. The function uses this to
count nonzeros per grid point.}

\item{y}{Numeric vector of length \code{n} with observed responses.
For \code{family == "binomial"}, values should be 0/1.}

\item{yhat}{Array of predictions for all grid points; expected shape
\code{n × n_lambda_sib × n_lambda_cou}. Typically produced by
\code{\link{predictcme}} with \code{type = "response"} (for deviance/BIC)
or \code{type = "link"} (if used differently).}

\item{n}{Integer number of observations (usually \code{length(y)}).}

\item{family}{Character; one of \code{"gaussian"}, \code{"binomial"}, or \code{"poisson"}.}

\item{type.measure}{Character; loss to compute. One of
\code{"deviance"}, \code{"class"}, or \code{"bic"}.}
}
\value{
An array with the same dimensions as \code{yhat}
(\code{n × n_lambda_sib × n_lambda_cou}) containing the pointwise loss for
each observation and grid point. (The caller usually averages over the first
dimension.)
}
\description{
Evaluates a loss/score for cross-validation across the full tuning grid
(columns × lambdas), using predictions \code{yhat} and a fitted CME object
to obtain model size (nonzeros). Supported measures are
\code{"deviance"}, \code{"class"}, and \code{"bic"}.
}
\details{
The number of selected coefficients at each grid point is computed as
\code{selmat[i,j] = sum(beta[,i,j] != 0)} from \code{fitobj$coefficients}.

\strong{Deviance:}
\itemize{
\item Gaussian: \eqn{(y - \hat y)^2}.
\item Binomial: \eqn{-2\,[y\log(\hat y) + (1-y)\log(1-\hat y)]}.
\item Poisson: \eqn{2\,[y\log y - y + \hat y - y\log \hat y]}, with
the convention \eqn{y\log y = 0} when \eqn{y = 0}.
}

\strong{Classification error (binomial only):}
returns a logical array \code{(yhat < 0.5) == y}. For non-binomial families,
this falls back to squared error.

\strong{BIC-like score:}
adds a penalty \eqn{\text{selmat}\cdot\log(n)/n} broadcast over samples to the
deviance for each family. Any \code{-Inf} created by logs is replaced by a large
finite value.
}
\seealso{
\code{\link{predictcme}}, \code{\link{cv.glmcmenet}}
}
