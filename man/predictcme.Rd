% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predictcme.R
\name{predictcme}
\alias{predictcme}
\title{Predict from a fitted CME model}
\usage{
predictcme(fit.cme, newx, type = c("link", "response", "class"))
}
\arguments{
\item{fit.cme}{A fitted CME model object as returned by \code{\link{glmcmenet}}
(or \code{cv.glmcmenet}$cme.fit). Must contain components
\code{$coefficients}, \code{$intercept}, and \code{$family}.}

\item{newx}{Numeric matrix of predictors for which to generate predictions.
The columns must correspond to the same design used in fitting
(typically \code{cbind(xme, xcme)} in the original order).}

\item{type}{Character; one of \code{"link"}, \code{"response"}, or \code{"class"}.
\code{"class"} is only valid for \code{family = "binomial"}.}
}
\value{
For \code{type = "link"}: the linear predictor \eqn{\eta}.

For \code{type = "response"}: the mean \eqn{\mu} (probabilities for binomial,
means for Gaussian/Poisson).

For \code{type = "class"} (binomial only): a 0/1 vector/matrix/array obtained by
thresholding \eqn{\eta > 0}.

In all cases, when both penalty grids have length greater than one, the shape is
\code{nrow(newx) × length(lambda.sib) × length(lambda.cou)} before \code{drop()}.
}
\description{
Computes predictions for new data using a model fit returned by
\code{\link{glmcmenet}} (or \code{cv.glmcmenet}$cme.fit). Returns
either the linear predictor (\code{"link"}), the mean/response
scale (\code{"response"}), or (for binomial models) hard classes
via a 0.5 threshold on the link (\code{"class"}).
}
\details{
If the fit was produced over a tuning grid, predictions are computed
for every grid point. Internally the function forms
\eqn{\eta = \text{intercept} + X \beta} and then maps \eqn{\eta}
to the mean scale via the model family (using an internal helper \code{pfamily}).
The returned object uses \code{\link[base]{drop}} to remove
length-1 dimensions, so the result may be a vector, matrix, or 3D array
depending on the grid sizes.
}
\examples{
\dontrun{
library(MASS)
n <- 50 #number of observations
p <- 20 #number of main effects
set.seed(1)
rho <- 0 #correlation
ones <- matrix(1,p,p)
covmtx <- rho*ones+(1-rho)*diag(p)
latmtx <- mvrnorm(n,p,mu=rep(0,p),Sigma=covmtx) #equicorrelated cov. matrix
memtx <- (latmtx>=0)-(latmtx<0) #simulate model matrix for MEs
model.mtx <- full.model.mtx(memtx)$model.mtx #generate model matrix for MEs and CMEs
glist <- grouplist(model.mtx)
## Set true model and generate response
num.act <- 2 # two siblings active
num.grp <- 4 # ... within four active groups
ind <- c()
for (ii in 1:num.grp){
 eff <- sample(seq(2*(p-1)),num.act)
 ind <- c(ind, p + eff + (ii-1)*(2*(p-1)))
}
colnames(model.mtx)[ind] # active CMEs
des.mtx <- model.mtx[,ind]
inter <- 0 #intercept
betatrue <- rep(1, length(ind))
xb <- inter + des.mtx \%*\% betatrue
y  <- rbinom(nrow(des.mtx), 1, 1 / (1 + exp(-xb)))
xme <- model.mtx[,1:p]
xcme <- model.mtx[,(p+1):ncol(model.mtx)]

# weights from ridge fit (recompute with current y)
cv.ridge <- glmnet::cv.glmnet(cbind(xme, xcme), y, family = "binomial", alpha = 0, standardize = FALSE)
coefs <- as.numeric(coef(cv.ridge, s = cv.ridge$lambda.min))[-1]
w  <- 1 / (abs(coefs) + 1 / n)       # element-wise
w[!is.finite(w)] <- 9.999e8
mg <- sapply(glist, function(idx) 1 / (sum(abs(coefs[idx])) + 1 / n))
mg[!is.finite(mg)] <- 9.999e8

cv.glmcme <- cv.glmcmenet(
  xme, xcme, y, family = "binomial", nfolds = 10,
  var.names=colnames(model.mtx), type.measure = "deviance",
  warm.str = "elastic", elastic_alpha=0.25,
  group.penalty = mg, penalty.factor = w
)

fit.cme <- cv.glmcme$cme.fit
sel.cme <- cv.glmcme$select.idx
colnames(model.mtx)[ind] #true model
colnames(model.mtx)[sel.cme] #selected effects from cmenet


# Prediction
set.seed(1000)
ntst <- 20
latmtx <- mvrnorm(ntst,p,mu=rep(0,p),Sigma=covmtx)
memtx <- (latmtx>=0)-(latmtx<0)
tst.mtx <- full.model.mtx(memtx)$model.mtx
xbtst <- inter + tst.mtx[, ind] \%*\% betatrue
ytst  <- rbinom(length(xbtst), 1, 1 / (1 + exp(-xbtst)))
pred.glmcme <- predictcme(fit.cme, newx = tst.mtx, type = "response")[,
                                                which(cv.glmcme$lambda.sib == cv.glmcme$params[1]),
                                                which(cv.glmcme$lambda.cou == cv.glmcme$params[2])]

}

}
\references{
Mak, S., & Wu, C. J. (2019). cmenet: A new method for bi-level variable selection
of conditional main effects. \emph{Journal of the American Statistical Association}, 114(526), 844-856.
}
\seealso{
\code{\link{glmcmenet}}, \code{\link{cv.glmcmenet}}
}
