% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv.glmcmenet.R
\name{cv.glmcmenet}
\alias{cv.glmcmenet}
\title{Cross-validated tuning for CME-regularized GLMs}
\usage{
cv.glmcmenet(
  xme,
  xcme,
  y,
  family = c("gaussian", "binomial", "poisson"),
  nfolds = 10,
  var.names = NULL,
  nlambda.sib = 20,
  nlambda.cou = 20,
  lambda.min.ratio = 1e-06,
  ngamma = 20,
  max.gamma = 150,
  ntau = 20,
  max.tau = 0.2,
  tau.min.ratio = 0.001,
  it.max = 250,
  it.max.cv = 25,
  type.measure = c("deviance", "class", "bic"),
  warm.str = c("lasso", "adaptive_lasso", "elastic", "ncvreg", "NULL"),
  elastic_alpha = NULL,
  penalty.factor = rep(1, ncol(xme) + ncol(xcme)),
  group.penalty = rep(1, 2 * ncol(xme)),
  screen_ind = F
)
}
\arguments{
\item{xme}{Numeric matrix (n × p\_me) of main-effect columns.}

\item{xcme}{Numeric matrix (n × p\_cme) of CME columns.}

\item{y}{Numeric response vector of length \code{n}.}

\item{family}{Character; one of \code{"gaussian"}, \code{"binomial"}, or \code{"poisson"}.}

\item{nfolds}{Integer number of CV folds (default \code{10}). Must be \eqn{\ge} 3.}

\item{var.names}{Optional character vector of variable names (length \code{ncol(xme)+ncol(xcme)})
used when reporting selected features.}

\item{nlambda.sib, }{nlambda.cou Integers: grid sizes for the sibling and cousin
penalty sequences in stage (2) (defaults \code{20} each).}

\item{lambda.min.ratio}{Smallest \eqn{\lambda} as a fraction of the largest \eqn{\lambda}
in each sequence (default \code{1e-6}).}

\item{ngamma, Integer}{Number of \code{gamma} values in stage (1) (default \code{20}).}

\item{max.gamma}{Largest \code{gamma} considered (default \code{150}).}

\item{ntau}{Integer number of \code{tau} values (default \code{20}).}

\item{max.tau}{Largest \code{tau} (default \code{0.2}).}

\item{tau.min.ratio}{Smallest \code{tau} as a fraction of \code{max.tau} (default \code{0.001}).}

\item{it.max, Integer}{Max iterations for the final refit on all data (default \code{250}).}

\item{it.max.cv}{Integer Max iterations used inside each CV fit (default \code{25}).}

\item{type.measure}{Character; CV loss to minimize. One of
\code{"deviance"}, \code{"class"} (misclassification for binomial), or \code{"bic"}.}

\item{warm.str}{Character warm-start strategy for the initial active set, one of
\code{"lasso"}, \code{"adaptive_lasso"}, \code{"elastic"}, \code{"ncvreg"}, or \code{"NULL"}.
If not \code{"NULL"}, external solvers (glmnet/ncvreg) are used to preselect variables.}

\item{elastic_alpha}{Optional numeric \eqn{\alpha \in [0,1]} for the elastic-net warm start.}

\item{penalty.factor}{Numeric vector of per-coefficient weights (length \code{p\_me+p\_cme});
modulates penalties (default all ones).}

\item{group.penalty}{Numeric vector of length \code{2*p\_me} with group weights for
siblings and cousins (ordered \code{c(m_sib, m_cou)}). Default all ones.}

\item{screen_ind}{Logical; enable screening rules inside fits (default \code{FALSE}).}
}
\value{
An object of class \code{"cv.glmcme"} (a list) with components:
\itemize{
\item \code{params} — named vector with selected \code{lambda.sib}, \code{lambda.cou},
\code{gamma}, and \code{tau}.
\item \code{cvm.gt} — matrix of mean CV loss over the \code{(tau, gamma)} grid.
\item \code{cvm.lambda} — matrix of mean CV loss over the \code{(lambda.sib, lambda.cou)} grid.
\item \code{cme.fit} — full-data fit from \code{glmcmenet()} using the selected parameters.
\item \code{select.idx}, \code{select.names} — indices and names of selected variables.
\item \code{lambda.sib}, \code{lambda.cou}, \code{gamma}, \code{tau}, \code{penalty.factor} — grids/inputs used.
\item \code{y}, \code{family} — echoed inputs.
}
}
\description{
Performs K-fold cross-validation to tune the CME model in two stages:
(1) a grid over \eqn{(\tau, \gamma)} then (2) a grid over \eqn{(\lambda_{\mathrm{sib}}, \lambda_{\mathrm{cou}})}.
Optionally uses warm starts from external solvers
(lasso / adaptive lasso / elastic net / MCP) to set an initial active set.
}
\details{
Stage (1) builds a grid for \code{tau} (from \code{max.tau} down to \code{max.tau * tau.min.ratio})
and a grid for \code{gamma} (from \code{max.gamma} down to a data-driven lower bound),
runs K-fold CV for each pair, and chooses the pair minimizing the mean CV loss.
Stage (2) then fixes \code{(tau, gamma)} at those values and cross-validates over
\code{lambda.sib × lambda.cou}.

Warm starts (when \code{warm.str != "NULL"}) set \code{act.vec} by fitting an external model:
lasso / adaptive lasso / elastic net via \pkg{glmnet}, or MCP via \pkg{ncvreg}.
}
\examples{
\dontrun{
library(MASS)
n <- 50 #number of observations
p <- 20 #number of main effects
set.seed(1)
rho <- 0 #correlation
ones <- matrix(1,p,p)
covmtx <- rho*ones+(1-rho)*diag(p)
latmtx <- mvrnorm(n,p,mu=rep(0,p),Sigma=covmtx) #equicorrelated cov. matrix
memtx <- (latmtx>=0)-(latmtx<0) #simulate model matrix for MEs
model.mtx <- full.model.mtx(memtx)$model.mtx #generate model matrix for MEs and CMEs
glist <- grouplist(model.mtx)
## Set true model and generate response
num.act <- 2 # two siblings active
num.grp <- 4 # ... within four active groups
ind <- c()
for (ii in 1:num.grp){
 eff <- sample(seq(2*(p-1)),num.act)
 ind <- c(ind, p + eff + (ii-1)*(2*(p-1)))
}
colnames(model.mtx)[ind] # active CMEs
des.mtx <- model.mtx[,ind]
inter <- 0 #intercept
betatrue <- rep(1, length(ind))
xb <- inter + des.mtx \%*\% betatrue
y  <- rbinom(nrow(des.mtx), 1, 1 / (1 + exp(-xb)))
xme <- model.mtx[,1:p]
xcme <- model.mtx[,(p+1):ncol(model.mtx)]

# weights from ridge fit (recompute with current y)
cv.ridge <- glmnet::cv.glmnet(cbind(xme, xcme), y, family = "binomial", alpha = 0, standardize = FALSE)
coefs <- as.numeric(coef(cv.ridge, s = cv.ridge$lambda.min))[-1]
w  <- 1 / (abs(coefs) + 1 / n)       # element-wise
w[!is.finite(w)] <- 9.999e8
mg <- sapply(glist, function(idx) 1 / (sum(abs(coefs[idx])) + 1 / n))
mg[!is.finite(mg)] <- 9.999e8

cvfit <- cv.glmcmenet(
  xme, xcme, y, family = "binomial", nfolds = 10,
  var.names=colnames(model.mtx), type.measure = "deviance",
  warm.str = "elastic", elastic_alpha=0.25,
  group.penalty = mg, penalty.factor = w
)
cvfit$params
cvfit$select.names

# Fit at selected parameters:
fit <- cvfit$cme.fit
}

}
\references{
Mak, S., & Wu, C. J. (2019). cmenet: A new method for bi-level variable selection
of conditional main effects. \emph{Journal of the American Statistical Association}, 114(526), 844-856.
}
\seealso{
\code{\link{glmcmenet}}, \code{\link{predictcme}}
}
